## 조건부확률
# 조건부확률은 어떤 사건이 참일 때 특정 사건의 확률이 얼마인지 일컫는 개념

# 수학적확률에서 관심있는 경우의 수를 가능한 모든 경우의 수로 나눠서 구할 수 있었음
# 조건은 모든 경우의 발생 가능성이 같다는 것
# 예) 주사위를 던졌을 때 5가 나올 확률: 1/6
#     홀수 눈 중에 5가 나올 확률: 1/3
#     P(5|홀수) = 1/3   # P(사건|조건)  # nolint
#               = P(5, 홀수) / P(홀수) = (1/6) / (1/2)

## 베이즈정리(Bayes' theorem)
# 앞 조건부확률의 공식을 추상적으로 표현하면
# P(A|B) = P(A,B)/P(B) # nolint
# 양변에 P(B)를 곱하면
# P(A,B) = P(A|B)xP(B)
# P(B,A) = P(B|A)xP(A)

# P(B,A) = P(A|B)xP(B)/P(A)
# 베이즈통계학 > 확률은 "믿음의 정도"

### 베이즈정리 시뮬레이션
# 코로나검사
# 모든 검사는 두 종류의 오류 가능성이 존재
# 1종 오류(Type 1 Error)-false positive : 음성인데 코로나라고 진단
# 2종 오류(Type 2 Error)-false negative : 양성인데 코로나라고 진단못함
# 의학에서 양성을 옳게 진단할 확률을 민감도(sensitivity),
# 음성을 옳게 진단할 확률을 특이도(specificity) 라고 한다
# 민감도는 2종 오류를 저지르지 않을 확률을 1에서 뺀 값
# 특이도는 1종 오류를 저지르지 않을 확률을 1에서 뺀 값

# 생각할 문제는 문제 1, 2종 오류의 확률이 둘다 충분히 낮다고 하더라도 상황에 따라
# 직관에 반하는 결과가 나올 수 있다
# 민감도와 특이도가 모두 99%인 검사가 있다고 가정
# 이렇게 높은 경우에도 검사 결과 양성을 판정된 사람들 중 10% 미만이 진양성(true positive)일 수 있다
# 나머지 90%는 질병이 없는데도 양성으로 잘못 진단된 것입니다. 왜 이런 일이 생길까요?
# 이유는 병을 가지고 있지 않은 사람들이 압도적으로 많은 경우라서 그렇다

# 만명 중에 10명이 병에 걸리고, 9990명이 건강하다고 가정
# 그럼 0.1%만 병이 있는 것이다. 여기서 구해주는 확률 0.1%를 유병률이라고 한다
# 그런데 병에 걸렸든 안걸렸든 검사의 정확성은 99%이기 때문에 병에 걸린 10명 전부,
# 병이 없는 9990명 중 9890명이 정확히 병이 없는 것으로 진단된다
# 실제로 진단된 사람은 병이 있는 10명과 병이 없는 100명이 진단되고 이것을 비율로 전환하면
# 10/110 실제로 병이 있는 비율은 약 10%이다

## 시뮬레이션 횟수 및 유병률
n_sim <- 100000
prevalence <- 0.001
## 검사의 민감도, 특이도
sensitivity <- 0.99
specificity <- 0.99
## 전체 질환 케이스 수, 실제 환자수, 오진 케이스 수
n_total_positive <- 0
n_true_positive <- 0
n_false_positive <- 0
## 시뮬레이션
for (i in 1:n_sim) {
    # 유병률에 따라 실제 병의 유무
    disease <- rbinom(1, 1, prevalence)

    if (disease == 0) {     # 실제로 병이 없는 경우
        diagnosis <- rbinom(1, 1, 1 - specificity)
        if (diagnosis == 1) {
            n_false_positive <- n_false_positive + 1
            n_total_positive <- n_total_positive + 1
        }
    }

    if (disease == 1) {     # 실제로 병이 있는 경우
        diagnosis <- rbinom(1, 1, sensitivity)
        if (diagnosis == 1) {
            n_total_positive <- n_total_positive + 1
            n_true_positive <- n_true_positive + 1
        }
    }
}

# 양성, 위양성, 진양성 수
print(n_total_positive)
print(n_false_positive)
print(n_true_positive)

# 위양성률
print(n_false_positive / n_total_positive)


## 확률분포
# : 총합이 1이 되어야 하는 확률이 각각의 경우에 어떻게 흩어져 있는지를 표현한 것을 말함
# 예) 동전던지기는 각각 확률이 0.5로 앞과 뒤로 존재 / 주사위는 각각의 눈의 수가 나올 확률이 1/6으로 분포
# 중요한 것은 분포는 배분이 같아야 할 필요가 없고, 그 결과의 합이 1이 되어야 한다

# 확률변수는 확률적으로 서로 다른 값을 가질 수 있는 어떤 것을 의미함
# -> 동전던지기에서 동전을 던졌을 때 나온 면을 확률변수라고 생각하면
#    확률변수 x가 갖는 값과 x가 특정 값을 가질 확률 사이의 대응 관계를 확률분포 정의

# 이산확률변수와 연속확률변수
# 이산확률변수: 확률변수가 가질 수 있는 값들이 떨어져 있는 것을 말함
#               ex) 주사위 눈의 수: 1 2 3 4 5 6
# 연속확률변수: 가질 수 있는 값들이 이어져 있는 것을 말함
#               ex) 사람의 키, 몸무게 등

### R로 이산확률분포 시뮬레이션
# 로또 복권
# 맞출 확률 0 ~ 6 까지 총 7가지 확률이 모두 더해져서 1이 되어야 이산확률분포가 된다
# 왜? 가능한 모든 경우를 고려했기 때문
# -수학적확률
# 0, 하나도 맞추지 못하는 경우: 45개에서 6개를 제외한 39개 중 6개를 선택하는 경우의 수
#                              = nCr(n=39, r=6) / nCr(n=45, r=6)
# 1, 하나만 맞는 경우: 6개중 하나를 고르고 나머지 39개 중 5개를 선택
#                              = nCr(n=6, r=1) * nCr(n=39, r=5) / nCr(n=45, r=6)
# 2, 두 개 맞는 경우: 6개중 두 개를 고르고 나머지 39개 중 4개를 선택
#                              = nCr(n=6, r=2) * nCr(n=39, r=4) / nCr(n=45, r=6)
# 3, 세 개 맞는 경우: 6개중 세 개를 고르고 나머지 39개 중 3개를 선택
#                              = nCr(n=6, r=3) * nCr(n=39, r=3) / nCr(n=45, r=6)
# 4, 네 개 맞는 경우: 6개중 네 개 고르고 나머지 39개 중 2개를 선택
#                              = nCr(n=6, r=4) * nCr(n=39, r=2) / nCr(n=45, r=6)
# 5, 다섯 개 맞는 경우: 6개중 다섯 개를 고르고 나머지 39개 중 1개를 선택
#                              = nCr(n=6, r=5) * nCr(n=39, r=1) / nCr(n=45, r=6)
# 6, 전부 맞는 경우: 6개 전부 맞춤
#                              = nCr(n=6, r=6)/ nCr(n=45, r=6)

# 공식화
# nCr(n=6,r=x) * nCr(n=39,r=6-x) / nCr(n=45, r=6)       # nolint
# 조합계산을 위해 choose()
# choose(n,r)                                           # nolint
lotto <- function(x) choose(6, x) * choose(39, 6 - x)

for (x in 0:6) print(lotto(x))

# 확률
lotto2 <- function(x) choose(6, x) * choose(39, 6 - x) / choose(45, 6)

for (i in 0:6) print(lotto2(i))


# 연속확률분포
# 균등분포(Uniform distribution)와 정규분포(Normal distribution)
# 균등분포: 어떤 구간이 주어졌을 때 그 구간 내에 모든 값이 발견될 가능성이 동일한 분포
# 예) 어떤 집단의 사람들의 키가 150~190cm 사이에 균등분포를 따른다면
# 이는 150~190cm 사이의 키가 다 같은 정도로 발견된다
# 현실적이지 않으나 통계학에서는 많이 사용됨

# 정규분포: 실생활에서도 자주 접하는 통계용어로, 다양한 사회, 자연현상들을 표현한다.
# 정규분포의 확률분포 그래프는 그렸을 때에 종형 곡선으로 종모양 그래프를 그리기도 한다

# 특징
# 1. 확률분포 곡선의 높이는 그 부근 값이 나올 확률과 관련된 값으로 곡선이 높은 곳 주변의 값들이
#    낮은 곳 주변의 값들보다 확률이 더 높다
# 2. 봉우리가 존재 그 봉우리에 가까울수록 관찰될 확률이 높다는 것을 의미
#    봉우리가 있는곳을 평균, 기대값이라한다
# 3. 봉우리를 중심으로 대칭의 구조를 갖고 있다
# 4. 봉우리를 중심으로 대칭되는 지점의 비율이 가까운 곳이 높다는 것을 알 수 있다
# 5. 1인 경우 약 70%의 표준편차(standard devition)
#    2인 경우 약 95% 정도가 나온다

# 왜 정규분포를 사용할까
# 1. 다양한 사회, 자연현상에 대한 우리의 직관과 부합하는 특징을 가지고 있다
# 2. 대부분의 자료는 평균을 중심으로 가까이 모여있거나 평균에서 양 또는 음의 방향으로 떨어진 정도가 비슷하다
#    이런 기대를 만족시켜주는 분포
# 3. 이 정규분포를 좋은 툴이라고 생각하고 있다. 좋다는 말은 근사적으로 나타내는데 쓸만하다는 의미를 가진다
#    실제와 물론 다를 수 있지만, 크게 차이가 나지 않는다면 현실을 단순화하여 이해할 수 있다는 의미이기도하다
# 저명한 통계학자 조지 박스가 확률분포의 유용함에 대해서 표현한 글 "모든 모형은 틀렸다. 하지만 그 중 어떤 것은 유용하다"
# 확률분포가 완벽하게 맞는 경우는 거의 없지만, 어느 정도 맞다면 그것은 없는 것보다 낮다는 것을 말한다

# 정규분포는 두 개의 중요한 숫자에 의해서 결정된다
# 첫번쨰 평균 또는 기대값
# 두번째 표준편차
#        표준편차가 클수록 그래프가 낮게 그려진다
curve(dnorm(x, mean = 30000, sd =  10000), 0, 60000, xlab = "확률변수", ylab = "확률")
# 평균과 표준편차를 이용하여 정규분포를 표기할 때
# N(0,1^2) 과 같이 표기

## R로 정규분포 다루기
# 2019년도 우리나라 1인당 국민 총소득(GNI)은 약 3만 6000달러라고 합니다. 편의상 3만 달러라고 가정
# 1인당 국민 총 소득은 국민 총 소득에서 총 인구로 나눈 수. 즉 일종의 평균값
# 표준편차 자료는 구하기 어렵기 때문에 편의상 1만 달러라고 가정
# 정규분포 표기 : N(30000, 10000^2)
# X는 개인 소득을 나타내는 확률변수
# 확률변수가 특정한 값을 가질 확률을 (원칙적으로는) 말할 수 없다
# 어떤 사람의 연간 소득이 2만 5000달러일 확률은 정규분포상에서는 0이다
# 현실적으로는 그렇지 않으나 정규분포에서는 그렇게 표시할 수 없다
# 소득이 2만 5000~30000달러 사이에 있을 확률을 앞의 정규분포로 구할 수 있다
# R에서 이 확률을 구하는데 사용할 함수는 pnorm(), p는 probability, norm은 정규분포를 의미
# pnorm(확률을 구할 값, 평균, 표준편차)

pnorm(35000, sd = 10000, mean = 30000) - pnorm(25000, sd = 10000, mean = 30000)
# 0.3829249

# pnorm()는 어떤 두 값 사이의 확률을 직접 구해주지는 않는다. 대신 음의 무한대로부터 첫번쨰 입력값까지 확률을 계산
# pnorm()을 이용하여 간접적으로 두 값 사이의 확률을 계산할 수 있게 된다.
# 2만 5000달러보다 작을 확률과 3만 5000달러보다 클 확률
pnorm(25000, 30000, 10000)
1 - pnorm(35000, 30000, 10000)

# 이 두 값은 0.3085로 같은 값을 가지게 되는데 이는 평균으로부터 동일하게 떨어져 있기 때문이다
# 정규분포를 따르는 모든 확률변수는 표준정규분포로 변환할 수 있다
# 이를 정규화라고 하고 평균을 0 표준편차를 1로 변환
# 정규화는 변수에서 평균을 빼고 표준편차로 나눔

# curve() 함수는 어떤 수학적 함수릐 그래프를 그리고 싶을 때에 사용
# 표준정규분포 함수를 그리고 싶기 때문에 처음 입력값으로 dnorm(x)를 사용
# pnorm() 확률을 계산하는데 썼다면, dnorm()은 거기에 사용된 확률함수의 값 자체를 구하는데 사용
# 이를 확률밀도함수라 한다
curve(dnorm(x), -3, 3, xlab = "Z", ylab = "density")

# 정규분포가 유용한 이유
# 1. 어떤 자료의 분포가 있을 경우 어떤 값보다 작거나 큰 값이 전체 몇 %인지 알아보려면
#    매번 일일이 자료를 찾아야 하는 불편함이 있는데, 이것을 대략 어느 구간에 있는지 바로 계산할 수 있다
# 2. 이런 유용한 근사값을 구하는데 단지 두 개의 숫자밖에 필요하지 않다


## 중심 극한 정리
# 독립적으로 추출된 충분히 큰 자료의 합이나 평균은 정규분포에 따른다
# 예) 이항분포에서 시행횟수 100회 성공률 0.5인 이항분포가 있다고 가정
#     여기서 자료를 계속 추출하면 성공 횟수가 대략 50을 중심으로 30~70, 이따금 20~80, 드물게 10~90사이의 숫자가 나온다
# 이항분포 자체가 성공 횟수의 합이라는 점을 감안하면, 이항분포를 따르는 변수는 결국 정규분포를 따를 것이다
# R코드로 지금까지 이야기한 이항분포에서 난수를 n_sim만큼 추출하여 모은 난수를 확인
n_sim <- 10000
y <- rbinom(n_sim, 100, 0.5)
hist(y, xlab = "X", ylab = "mass", main = "Binom(100, 0, 5)", prob = T)
curve(dnorm(x, 50, 5), 25, 75, add = T, lty = 2, col = "red")

# Bin(n,p) ~= N(np, np(1-p))

# 중심 극한 정리가 중요한 이유는 이항분포뿐만 아니라 어떤 확률변수에 대해서도 적용된다

# 중심 극한 정리는 (거의) 모든 분포에 적용된다
# 20세 이상 성인 전체의 집단이 있다고 가정
# 이 집단의 키의 분포는 어떻게 생겼을까? 하나의 봉우리를 가지는 분포일까요?
# 봉우리는 두 개가 만들어진다
# 성별로 키의 분포가 다르기 때문
# 이런 분포에서 자료를 뽑아 평균을 계산해도 그 평균은 정규분포를 따를까?
# 만약 중심 극한 정리가 성립된다면 가능하다

n_sim <- 1000   # 시뮬레이션 횟수
n <- 30         # 한번 추출할 때 30명을 추출
means <- vector(length = n_sim)

for (i in 1:n_sim) {
    y <- vector(length = n)     # 길이가 n인 저장소를 만든다
    for (j in 1:30) {            # 30명씩 추출
        gender <- rbinom(1, 1, 0.5)     # 개인별로 성별을 추출
        if (gender == 0) {      # 여성집단
            y[j] <- rnorm(1, 160, 5) # 여성집단에서 키를 추출
        } else {
            y[j] <- rnorm(1, 175, 5) # 남성집단에서 키를 추출
        }
    }
    means[i] <- mean(y)
}

hist(means, xlab = "mean_height", ylab = "Distribution of means", prob = T)

## 아들, 딸 역설
